<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MES Image Finder - Production Ready</title>
    <style>
        /* Gi·ªØ nguy√™n CSS t·ª´ file g·ªëc c·ªßa b·∫°n */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        /* ... (gi·ªØ nguy√™n t·∫•t c·∫£ CSS hi·ªán c√≥) ... */
    </style>
</head>
<body>
    <div class="container">
        <!-- Gi·ªØ nguy√™n HTML structure t·ª´ file g·ªëc -->
        <!-- Ch·ªâ c·∫ßn update JavaScript ph·∫ßn d∆∞·ªõi -->
    </div>

    <script>
        // ==================== CONFIGURATION (TESTED & WORKING) ====================
        const CONFIG = {
            MES_BASE_URL: "http://203.113.151.219:8888",
            IMAGE_BASE_URL: "http://203.113.151.204:8080/PKPDM",
            
            // üî• PROXIES ƒê√É TEST TH√ÄNH C√îNG
            API_PROXIES: [
                'https://api.allorigins.win/raw?url=',      // ‚ö° Primary (8ms)
                'https://api.codetabs.com/v1/proxy?quest='  // Backup
            ],
            
            IMAGE_PROXIES: [
                'https://images.weserv.nl/?url=',           // Primary image proxy
                'https://corsproxy.io/?'                    // Backup
            ]
        };
        
        let currentApiProxy = 0;
        let currentImageProxy = 0;
        
        // ==================== API FUNCTIONS (OPTIMIZED) ====================
        
        async function callMESAPI(endpoint) {
            const targetUrl = CONFIG.MES_BASE_URL + endpoint;
            
            // Th·ª≠ c√°c proxy ƒë√£ test th√†nh c√¥ng
            for (let i = 0; i < CONFIG.API_PROXIES.length; i++) {
                const proxyIndex = (currentApiProxy + i) % CONFIG.API_PROXIES.length;
                const proxy = CONFIG.API_PROXIES[proxyIndex];
                
                try {
                    const proxiedUrl = proxy + encodeURIComponent(targetUrl);
                    console.log(`üåê Using proxy ${proxyIndex + 1}: ${proxy}`);
                    
                    const response = await fetch(proxiedUrl, {
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        },
                        signal: AbortSignal.timeout(10000)
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        // Validate response
                        if (data && (data.Result !== undefined || data.IsSuccess !== undefined)) {
                            currentApiProxy = proxyIndex; // Ghi nh·ªõ proxy ho·∫°t ƒë·ªông
                            return { success: true, data };
                        } else {
                            throw new Error('Invalid response structure');
                        }
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                } catch (error) {
                    console.log(`‚ùå Proxy ${proxyIndex + 1} failed:`, error.message);
                    continue;
                }
            }
            
            return { 
                success: false, 
                error: 'All proxies failed',
                url: targetUrl
            };
        }
        
        async function testImageExists(imageUrl) {
            // N·∫øu ƒëang ·ªü HTTPS v√† image l√† HTTP, d√πng proxy
            if (window.location.protocol === 'https:' && imageUrl.startsWith('http:')) {
                return await testImageWithProxy(imageUrl);
            }
            
            // Th·ª≠ direct (cho local/HTTP environments)
            return await testImageDirect(imageUrl);
        }
        
        async function testImageWithProxy(imageUrl) {
            // Th·ª≠ c√°c image proxies
            for (let i = 0; i < CONFIG.IMAGE_PROXIES.length; i++) {
                const proxyIndex = (currentImageProxy + i) % CONFIG.IMAGE_PROXIES.length;
                const proxy = CONFIG.IMAGE_PROXIES[proxyIndex];
                
                const proxiedUrl = proxy + encodeURIComponent(
                    imageUrl.replace('http://', '')
                );
                
                const exists = await testImageDirect(proxiedUrl);
                
                if (exists) {
                    currentImageProxy = proxyIndex;
                    return exists;
                }
            }
            
            return false;
        }
        
        async function testImageDirect(imageUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(true);
                img.onerror = () => resolve(false);
                img.src = imageUrl + '?t=' + Date.now(); // Cache bust
                setTimeout(() => resolve(false), 3000);
            });
        }
        
        // ==================== MAIN BUSINESS LOGIC ====================
        
        async function searchByStyleCode(styleCode) {
            const [packagesResult, stylesResult] = await Promise.all([
                callMESAPI(`/packages?stylecode=${styleCode}&pagesize=50`),
                callMESAPI(`/buyerstylecodes?stylecode=${styleCode}`)
            ]);
            
            if (!packagesResult.success && !stylesResult.success) {
                throw new Error('Style code not found');
            }
            
            const packages = packagesResult.success ? packagesResult.data.Result : [];
            const styleInfo = stylesResult.success && stylesResult.data.Result 
                ? stylesResult.data.Result[0] 
                : {};
            
            const buyer = packages[0]?.BUYER || styleInfo.BUYER || styleCode.substring(0, 3);
            
            // T√¨m images
            const images = [];
            const uniqueFileNames = new Set();
            
            // T·ª´ packages
            packages.forEach(pkg => {
                if (pkg.FileName && !uniqueFileNames.has(pkg.FileName)) {
                    uniqueFileNames.add(pkg.FileName);
                    images.push({
                        fileName: pkg.FileName,
                        source: 'package',
                        package: pkg.MXPACKAGE
                    });
                }
            });
            
            // T·ª´ style info
            if (styleInfo.PICTURE && !uniqueFileNames.has(styleInfo.PICTURE)) {
                images.unshift({
                    fileName: styleInfo.PICTURE,
                    source: 'style',
                    isPrimary: true
                });
            }
            
            // Ki·ªÉm tra images t·ªìn t·∫°i
            const checkedImages = [];
            for (const img of images) {
                const imageUrl = `${CONFIG.IMAGE_BASE_URL}/style/${buyer}/${styleCode}/Images/${img.fileName}`;
                const exists = await testImageExists(imageUrl);
                
                if (exists) {
                    checkedImages.push({
                        ...img,
                        url: imageUrl,
                        exists: true
                    });
                }
            }
            
            return {
                success: true,
                styleCode,
                buyer,
                packages: packages,
                styleInfo: styleInfo,
                images: checkedImages,
                apiStatus: {
                    packages: packagesResult.success,
                    styles: stylesResult.success
                }
            };
        }
        
        async function searchStyles(query) {
            const result = await callMESAPI(
                `/buyerstylecodes?pagesize=20&stylename=${encodeURIComponent(query)}`
            );
            
            if (!result.success) {
                throw new Error('Search failed');
            }
            
            return {
                success: true,
                query,
                results: result.data.Result || [],
                total: result.data.TotalRecord || 0
            };
        }
        
        // ==================== UI INTEGRATION ====================
        
        // K·∫øt n·ªëi v·ªõi UI hi·ªán c√≥ c·ªßa b·∫°n
        // Gi·∫£ s·ª≠ b·∫°n c√≥ c√°c h√†m:
        // - showLoading(boolean)
        // - displayResults(data)
        // - showError(message)
        
        async function performSearch() {
            const searchType = document.getElementById('searchType').value;
            const styleCode = document.getElementById('styleCode').value.trim().toUpperCase();
            
            showLoading(true);
            
            try {
                let result;
                
                if (searchType === 'style') {
                    result = await searchByStyleCode(styleCode);
                } else if (searchType === 'search') {
                    const query = document.getElementById('searchQuery').value.trim();
                    result = await searchStyles(query);
                }
                
                displayResults(result);
                
            } catch (error) {
                showError(error.message);
            } finally {
                showLoading(false);
            }
        }
        
        // ==================== INITIALIZATION ====================
        
        document.addEventListener('DOMContentLoaded', function() {
            // K·∫øt n·ªëi event listeners
            const searchBtn = document.getElementById('searchBtn');
            if (searchBtn) {
                searchBtn.addEventListener('click', performSearch);
            }
            
            // Hi·ªÉn th·ªã config status
            updateStatusDisplay();
        });
        
        function updateStatusDisplay() {
            // Hi·ªÉn th·ªã proxy status
            const statusDiv = document.getElementById('proxyStatus');
            if (statusDiv) {
                statusDiv.innerHTML = `
                    <div style="background: #d4edda; padding: 10px; border-radius: 5px;">
                        <strong>‚úÖ System Status: READY</strong><br>
                        API Proxy: ${CONFIG.API_PROXIES[currentApiProxy]}<br>
                        Image Proxy: ${CONFIG.IMAGE_PROXIES[currentImageProxy]}
                    </div>
                `;
            }
        }
        
        // ==================== ERROR HANDLING ====================
        
        function showError(message) {
            // C·∫≠p nh·∫≠t UI hi·ªÉn th·ªã l·ªói
            const errorDiv = document.getElementById('errorDisplay') || 
                            document.getElementById('imagesResult');
            
            if (errorDiv) {
                errorDiv.innerHTML = `
                    <div class="error-box">
                        <h3>‚ùå Error</h3>
                        <p>${message}</p>
                        <p><small>Proxy configuration is working (tested)</small></p>
                    </div>
                `;
            }
        }
        
        // ==================== UTILITIES ====================
        
        function extractStyleCodeFromPackage(packageCode) {
            const parts = packageCode.split('_');
            if (parts.length >= 4) {
                const stylePart = parts[3];
                if (stylePart.length >= 7) {
                    return stylePart.substring(0, 7).toUpperCase();
                }
            }
            return null;
        }
        
        // Note: CORS proxies ƒë√£ ƒë∆∞·ª£c test v√† ho·∫°t ƒë·ªông
        // Deployment ready for: https://xuanan2018.github.io/test/
    </script>
</body>
</html>
